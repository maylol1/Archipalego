<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>UNO Deluxe — Fixed & Polished</title>
<style>
  :root{
    --bg1:#06121a; --bg2:#041827;
    --card-w:92px; --card-h:128px;
    --red:#ef4444; --yellow:#f59e0b; --green:#10b981; --blue:#3b82f6; --wild:#111827;
    --muted:#9fb0c8;
  }
  *{box-sizing:border-box;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;color:#eaf6ff}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg1),var(--bg2))}
  .container{max-width:1240px;margin:18px auto;padding:12px;display:grid;grid-template-columns:1fr 380px;gap:12px}
  .board{background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);padding:12px;border-radius:12px;min-height:80vh;position:relative;overflow:hidden}
  .panel{background:rgba(1,6,12,0.48);padding:12px;border-radius:10px}
  .topRow{display:flex;justify-content:space-between;align-items:center;padding:8px}
  .centerArea{display:flex;flex-direction:column;align-items:center;justify-content:center;margin-top:8px}
  .piles{display:flex;gap:24px;align-items:center}
  .pile{width:var(--card-w);height:var(--card-h);border-radius:12px;box-shadow:0 12px 36px rgba(2,6,12,0.6);display:flex;align-items:center;justify-content:center;position:relative;overflow:visible}
  .cardBack{width:100%;height:100%;border-radius:12px;background:linear-gradient(180deg,#083b49,#042a37);display:flex;align-items:center;justify-content:center;color:#bfe7f8;font-weight:800;letter-spacing:1px}
  #discardTop{width:100%;height:100%;border-radius:12px;display:flex;align-items:center;justify-content:center;font-weight:900;color:#021018}
  .playersTop{display:flex;justify-content:center;gap:12px;align-items:flex-end;padding:12px}
  .aiSlot{display:flex;flex-direction:column;align-items:center;gap:6px;width:160px}
  .aiCards{display:flex;gap:6px}
  .aiCard{width:34px;height:56px;border-radius:8px;background:#021826;box-shadow:inset 0 -6px 12px rgba(0,0,0,0.4)}
  .statusBar{position:absolute;left:16px;top:12px;background:rgba(0,0,0,0.36);padding:8px;border-radius:8px}
  .turnBadge{position:absolute;right:16px;top:12px;background:rgba(0,0,0,0.36);padding:8px;border-radius:8px}
  .log{height:300px;overflow:auto;padding:8px;background:rgba(0,0,0,0.12);border-radius:8px;margin-top:10px;font-size:13px}
  .controls{display:flex;gap:8px;align-items:center;margin-bottom:8px}
  button{background:#0b1620;border:1px solid rgba(255,255,255,0.04);color:var(--muted);padding:8px 10px;border-radius:8px;cursor:pointer}
  select,input{padding:6px;border-radius:6px;background:transparent;border:1px solid rgba(255,255,255,0.04);color:#eaf6ff}
  .playerHandWrap{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;display:flex;gap:10px;align-items:flex-end;padding:8px;pointer-events:none}
  .handCard{width:var(--card-w);height:var(--card-h);border-radius:12px;display:flex;flex-direction:column;align-items:center;justify-content:center;font-weight:900;color:#021018;pointer-events:auto;cursor:pointer;transition:transform .22s cubic-bezier(.17,.67,.32,1), box-shadow .18s ease, opacity .18s ease}
  .handCard:hover{transform:translateY(-10px) scale(1.02);box-shadow:0 28px 56px rgba(3,7,12,0.6)}
  .face-red{background:linear-gradient(180deg,#ff7b7b,var(--red));color:white}
  .face-yellow{background:linear-gradient(180deg,#ffde7a,var(--yellow));color:#021018}
  .face-green{background:linear-gradient(180deg,#8cefc2,var(--green));color:#021018}
  .face-blue{background:linear-gradient(180deg,#a7d3ff,var(--blue));color:#021018}
  .face-wild{background:linear-gradient(180deg,#3a3a3a,var(--wild));color:white}
  .cardSymbol{font-size:34px;line-height:1}
  .cardSub{font-size:12px;color:rgba(0,0,0,0.35);margin-top:6px}
  .glowActive{box-shadow:0 24px 60px rgba(125,211,252,0.12), 0 6px 18px rgba(125,211,252,0.06)}
  .playedFloating{position:absolute;transition:transform .52s cubic-bezier(.17,.67,.32,1), opacity .4s ease;will-change:transform;z-index:999}
  .fadeIn{animation:fadeIn .28s ease}
  @keyframes fadeIn{from{opacity:0;transform:scale(.96)}to{opacity:1;transform:scale(1)}}
  .reverseSpin{animation:spinRev 0.8s ease}
  @keyframes spinRev{from{transform:rotate(0)}to{transform:rotate(360deg)}}
  .colorPickPanel{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(3,6,9,0.96);padding:12px;border-radius:12px;display:flex;gap:8px;z-index:1200}
  .colorPickBtn{width:64px;height:64px;border-radius:10px;border:3px solid rgba(0,0,0,0.18);cursor:pointer;box-shadow:0 14px 40px rgba(0,0,0,0.6)}
  .hidden{display:none}
  .centerOverlay{position:absolute;left:50%;top:52%;transform:translate(-50%,-50%);pointer-events:none}
  .victory{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(2,6,12,0.9);padding:18px;border-radius:12px;z-index:2000;text-align:center}
  .mini{font-size:13px;color:var(--muted)}
  @media(max-width:980px){ .container{grid-template-columns:1fr} .playerHandWrap{left:50%;transform:translateX(-50%);bottom:8px} }
  /* Hand fan spacing: use CSS variable to calculate translation to ensure stable layout */
  .handContainer{display:flex;gap:10px;padding:6px;pointer-events:auto}
</style>
</head>
<body>
<div class="container">
  <div class="board panel" id="board" tabindex="0">
    <div class="statusBar mini" id="status">UNO Deluxe — select AI count and press Start</div>
    <div class="turnBadge mini" id="turnBadge">Turn: -</div>

    <div class="playersTop" id="playersTop"></div>

    <div class="centerArea">
      <div id="centerAction" class="mini" style="margin-bottom:10px">Draw pile and discard</div>
      <div class="piles">
        <div class="pile" id="drawPile" title="Draw Pile"><div class="cardBack mini" id="drawBack">Deck</div></div>
        <div class="pile" id="discardPile" title="Discard Pile"><div id="discardTop" style="width:100%;height:100%;border-radius:12px;display:flex;align-items:center;justify-content:center;font-weight:900"></div></div>
      </div>
    </div>

    <div id="playedArea" style="position:absolute;left:50%;top:40%;transform:translateX(-50%);pointer-events:none"></div>

    <div id="colorPicker" class="colorPickPanel hidden">
      <div class="mini" style="align-self:center;margin-right:6px">Choose color</div>
      <div class="colorPickBtn face-red" data-color="red"></div>
      <div class="colorPickBtn face-yellow" data-color="yellow"></div>
      <div class="colorPickBtn face-green" data-color="green"></div>
      <div class="colorPickBtn face-blue" data-color="blue"></div>
    </div>

    <div id="victoryOverlay" class="victory hidden"></div>
  </div>

  <aside class="panel">
    <div class="topRow">
      <div>
        <div class="mini">Players</div>
        <div class="big" id="playersCountLabel">Human + 2 AIs</div>
      </div>
      <div>
        <div class="mini">AI Mode</div>
        <div class="mini">Realistic (1–1.5s)</div>
      </div>
    </div>

    <div class="controls">
      <label class="mini">AI Opponents</label>
      <select id="aiCountSelect"><option value="2">2 AI (3 players)</option><option value="3">3 AI (4 players)</option></select>
      <button id="startBtn">Start</button>
      <button id="newBtn">New Round</button>
    </div>

    <div style="margin-top:8px;">
      <button id="drawBtn">Draw Card</button>
      <button id="unoBtn">Call UNO</button>
    </div>

    <div style="margin-top:12px" class="mini">Log</div>
    <div id="log" class="log mini"></div>

  </aside>
</div>

<!-- Player hand overlay at bottom -->
<div class="playerHandWrap" id="playerHand">
  <div class="handContainer" id="handContainer"></div>
</div>

<script>
/*
  UNO Deluxe — Fixed & Polished
  Key fixes:
  - AI turn flow: AI acts once per turn, waits 1–1.5s, won't "dump" hand.
  - Drawing: player hand layout is stable (flex), draw action re-renders full hand to avoid shift.
  - Draw end-turn: if drawn card not playable, turn automatically passes to next player.
  - Wild handling: color is finalized before AI chooses.
  - Animations: polished slide-to-discard and draw feedback.
  - Single-file, WebAudio-based sound, select AI count before start.
*/

/* ========= Audio (WebAudio) ========= */
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
function ensureAudio(){
  if(!audioCtx){ audioCtx = new AudioCtx(); if(audioCtx.state === 'suspended'){ const resume = ()=>audioCtx.resume(); window.addEventListener('click', resume, {once:true}); } }
}
function playSeq(seq){
  if(!audioCtx) return;
  const now = audioCtx.currentTime;
  let t = now;
  for(const s of seq){
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = s.type || 'sine';
    o.frequency.setValueAtTime(s.freq, t);
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime((s.vol||0.06), t + 0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, t + s.dur - 0.02);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(t); o.stop(t + s.dur);
    t += s.dur;
  }
}
function sfxShuffle(){ ensureAudio(); playSeq([{freq:1400,dur:0.06,type:'sawtooth',vol:0.05},{freq:900,dur:0.08,type:'sawtooth',vol:0.05},{freq:700,dur:0.09,type:'sine',vol:0.04}]); }
function sfxPlay(){ ensureAudio(); playSeq([{freq:880,dur:0.09,type:'triangle',vol:0.07},{freq:1320,dur:0.06,type:'sine',vol:0.05}]); }
function sfxDraw(){ ensureAudio(); playSeq([{freq:540,dur:0.08,type:'sine',vol:0.06},{freq:700,dur:0.06,type:'sine',vol:0.045}]); }
function sfxSkip(){ ensureAudio(); playSeq([{freq:420,dur:0.08,type:'square',vol:0.06},{freq:300,dur:0.05,type:'square',vol:0.045}]); }
function sfxReverse(){ ensureAudio(); playSeq([{freq:720,dur:0.09,type:'triangle',vol:0.07},{freq:880,dur:0.08,type:'triangle',vol:0.055}]); }
function sfxUno(){ ensureAudio(); playSeq([{freq:1000,dur:0.18,type:'sine',vol:0.09},{freq:1200,dur:0.12,type:'sine',vol:0.07}]); }
function sfxWin(){ ensureAudio(); playSeq([{freq:880,dur:0.12,type:'triangle',vol:0.09},{freq:1100,dur:0.10,type:'triangle',vol:0.08},{freq:1320,dur:0.14,type:'sawtooth',vol:0.1}]); }

/* ========= Deck & Card helpers ========= */
const COLORS = ['red','yellow','green','blue'];
function createDeck(){
  const deck = [];
  for(const c of COLORS){
    deck.push({color:c, value:'0'});
    for(let n=1;n<=9;n++){ deck.push({color:c,value:String(n)}); deck.push({color:c,value:String(n)}); }
    for(let i=0;i<2;i++){ deck.push({color:c,value:'skip'}); deck.push({color:c,value:'reverse'}); deck.push({color:c,value:'draw2'}); }
  }
  for(let i=0;i<4;i++) deck.push({color:'wild', value:'wild'});
  for(let i=0;i<4;i++) deck.push({color:'wild', value:'wild4'});
  return deck;
}
function shuffle(arr){
  for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; }
  sfxShuffle();
  return arr;
}

/* ========= Game state ========= */
let deck = [], discard = [];
let players = []; // {name, hand:[], isAI, unoCalled:false}
let current = 0, direction = 1;
let topColor = null, topValue = null;
let waitingColor = null; // {playerIndex, playedCard}
let aiCount = 2;
let busy = false; // lock UI during animations

/* ========= DOM refs ========= */
const board = document.getElementById('board');
const drawBack = document.getElementById('drawBack');
const discardTop = document.getElementById('discardTop');
const playersTopEl = document.getElementById('playersTop');
const handContainer = document.getElementById('handContainer');
const logEl = document.getElementById('log');
const statusEl = document.getElementById('status');
const turnBadge = document.getElementById('turnBadge');
const startBtn = document.getElementById('startBtn');
const newBtn = document.getElementById('newBtn');
const drawBtn = document.getElementById('drawBtn');
const unoBtn = document.getElementById('unoBtn');
const aiCountSelect = document.getElementById('aiCountSelect');
const playersCountLabel = document.getElementById('playersCountLabel');
const colorPicker = document.getElementById('colorPicker');
const colorBtns = document.querySelectorAll('.colorPickBtn');
const playedArea = document.getElementById('playedArea');
const victoryOverlay = document.getElementById('victoryOverlay');

/* ========= Utility functions ========= */
function log(msg){ const d=document.createElement('div'); d.textContent=msg; logEl.prepend(d); }
function setStatus(s){ statusEl.textContent=s; }
function setTurnBadge(){ turnBadge.textContent = `Turn: ${players[current].name}`; }
function cardSymbol(c){
  if(!c) return '';
  if(c.color === 'wild') return c.value === 'wild4' ? '+4' : '★';
  if(c.value==='skip') return '⏭';
  if(c.value==='reverse') return '⤾';
  if(c.value==='draw2') return '+2';
  return c.value;
}
function cardClass(c){
  if(!c) return '';
  if(c.color==='wild') return 'face-wild';
  return c.color==='red' ? 'face-red' : c.color==='yellow' ? 'face-yellow' : c.color==='green' ? 'face-green' : 'face-blue';
}

/* ========= Rendering ========= */
function renderDiscardTop(){
  const top = discard[discard.length-1];
  if(!top){ discardTop.innerHTML=''; topColor = topValue = null; return; }
  const displayColor = (top.color === 'wild' && top.chosenColor) ? top.chosenColor : top.color;
  const temp = {...top, color: displayColor};
  discardTop.innerHTML = `<div style="width:100%;height:100%;border-radius:12px;display:flex;align-items:center;justify-content:center" class="${cardClass(temp)}"><div style="font-size:30px">${cardSymbol(temp)}</div></div>`;
  topColor = displayColor; topValue = top.value;
}
function renderPiles(){
  drawBack.textContent = deck.length;
  renderDiscardTop();
}

/* stable hand layout using flex: re-render whole hand after any change */
function renderPlayerHand(){
  handContainer.innerHTML = '';
  const hand = players[0].hand;
  for(let i=0;i<hand.length;i++){
    const c = hand[i];
    const el = document.createElement('div');
    el.className = 'handCard ' + cardClass(c);
    el.innerHTML = `<div class="cardSymbol">${cardSymbol(c)}</div><div class="cardSub">${c.color==='wild' ? (c.value==='wild4'?'+4':'WILD') : ''}</div>`;
    el.style.pointerEvents = (current === 0 && !busy) ? 'auto' : 'none';
    // show playable visual
    if(canPlayCard(c, 0)) { el.style.boxShadow = '0 28px 56px rgba(3,7,12,0.6), 0 0 0 6px rgba(125,211,252,0.06)'; el.style.transform='translateY(-6px)'; }
    el.addEventListener('click', ()=> {
      if(busy) return;
      if(current !== 0) { setStatus('Not your turn'); return; }
      if(!canPlayCard(c, 0)){ setStatus('Cannot play this card'); return; }
      const idx = players[0].hand.indexOf(c);
      playerPlay(idx);
    });
    handContainer.appendChild(el);
  }
}

/* AI slots render */
function renderAITop(){
  playersTopEl.innerHTML = '';
  for(let i=1;i<players.length;i++){
    const p = players[i];
    const slot = document.createElement('div');
    slot.className = 'aiSlot';
    const row = document.createElement('div'); row.className='aiCards';
    const show = Math.min(8, p.hand.length);
    for(let k=0;k<show;k++){ const card=document.createElement('div'); card.className='aiCard'; row.appendChild(card); }
    const label = document.createElement('div'); label.className='mini'; label.textContent = `${p.name} (${p.hand.length})`;
    slot.appendChild(row); slot.appendChild(label);
    playersTopEl.appendChild(slot);
  }
}

/* render everything */
function renderAll(){
  renderAITop(); renderPlayerHand(); renderPiles(); setTurnBadge();
}

/* ========= Deck management ========= */
function reshuffleIfNeeded(){
  if(deck.length === 0){
    if(discard.length <= 1) return;
    const top = discard.pop();
    deck = shuffle(discard.splice(0, discard.length));
    discard = [top];
    log('Reshuffled discard into deck');
  }
}

/* ========= Game start / restart ========= */
function startGame(){
  ensureAudio();
  aiCount = parseInt(aiCountSelect.value,10);
  players = [];
  players.push({name:'You', hand:[], isAI:false, unoCalled:false});
  for(let i=1;i<=aiCount;i++) players.push({name:`AI ${i}`, hand:[], isAI:true, unoCalled:false});
  playersCountLabel.innerText = `Human + ${aiCount} AI`;
  deck = shuffle(createDeck());
  discard = [];
  for(let r=0;r<7;r++){ for(let p=0;p<players.length;p++){ players[p].hand.push(deck.pop()); } }
  let starter = deck.pop();
  while(starter.value==='wild' || starter.value==='wild4'){ deck.unshift(starter); shuffle(deck); starter = deck.pop(); }
  discard.push(starter);
  topColor = (starter.color==='wild' && starter.chosenColor) ? starter.chosenColor : starter.color;
  topValue = starter.value;
  current = 0; direction = 1; waitingColor = null; busy = false;
  renderAll();
  setStatus('Game started');
  log('Game started. Top: ' + cardText(starter));
  // apply initial card special
  if(starter.value === 'skip'){ log('Initial card Skip — first player skipped'); current = getNext(current); }
  else if(starter.value === 'reverse'){ log('Initial card Reverse — direction changed'); direction *= -1; }
  else if(starter.value === 'draw2'){ const nxt = getNext(current); drawCards(nxt,2); log(`${players[nxt].name} draws 2`); current = getNext(nxt); }
  renderAll(); updateTurn();
}

function cardText(c){ if(!c) return ''; if(c.value==='skip') return `${c.color} SKIP`; if(c.value==='reverse') return `${c.color} REVERSE`; if(c.value==='draw2') return `${c.color} +2`; if(c.value==='wild') return 'WILD'; if(c.value==='wild4') return 'WILD +4'; return `${c.color} ${c.value}`; }

/* ========= Turn helpers ========= */
function getNext(i){ return (i + direction + players.length) % players.length; }
function updateTurn(){
  renderAll();
  // if someone played wild and waiting for color, do not auto-run AI
  if(waitingColor) return;
  if(players[current].isAI){
    setTimeout(() => aiTurn(), 1000 + Math.random()*500); // realistic delay
  } else {
    // enable player input
    setStatus('Your turn');
  }
}

/* ========= Play validation ========= */
function canPlayCard(card, playerIndex){
  if(!card) return false;
  if(card.color === 'wild'){
    if(card.value === 'wild4'){
      // illegal if player has color match
      const hand = players[playerIndex].hand;
      const hasColorMatch = hand.some(h => h.color === topColor && h.color !== 'wild');
      if(hasColorMatch) return false;
      return true;
    }
    return true;
  }
  if(topColor === null) return true;
  if(card.color === topColor) return true;
  if(card.value === topValue) return true;
  return false;
}

/* ========= Player actions ========= */
function playerPlay(cardIndex){
  if(busy) return;
  if(current !== 0) { setStatus('Not your turn'); return; }
  if(cardIndex < 0 || cardIndex >= players[0].hand.length) return;
  const card = players[0].hand[cardIndex];
  if(!canPlayCard(card,0)){ setStatus('Cannot play that card'); return; }
  // penalty check for forgotten UNO
  checkUnoPenalty(0);
  // remove and push to discard
  const [played] = players[0].hand.splice(cardIndex,1);
  discard.push(played);
  renderAll();
  animatePlay(played,0);
  sfxPlay();
  log(`You played ${cardText(played)}`);
  if(played.color === 'wild'){
    waitingColor = {playerIndex:0, played:played};
    showColorPicker();
  } else {
    topColor = played.color; topValue = played.value;
    setTimeout(()=> applyEffect(0, played), 420);
  }
  // check UNO auto-call
  if(players[0].hand.length === 1){ setStatus('You have 1 card - press UNO to call!'); }
  if(players[0].hand.length === 0){ showVictory('You'); }
  renderAll();
}

/* ========= Apply card effects ========= */
function applyEffect(pid, card){
  if(card.value === 'skip'){
    sfxSkip();
    log(`${players[getNext(pid)].name} is skipped`);
    current = getNext(getNext(pid));
  } else if(card.value === 'reverse'){
    sfxReverse();
    direction *= -1;
    log('Direction reversed');
    if(players.length === 2) current = getNext(getNext(pid)); else current = getNext(pid);
  } else if(card.value === 'draw2'){
    const nxt = getNext(pid);
    sfxDraw(); drawCards(nxt, 2);
    log(`${players[nxt].name} draws 2`);
    current = getNext(nxt);
  } else if(card.value === 'wild4'){
    const nxt = getNext(pid);
    sfxDraw(); drawCards(nxt,4);
    log(`${players[nxt].name} draws 4`);
    current = getNext(nxt);
  } else {
    current = getNext(pid);
  }
  updateTurn();
}

/* ========= Draw logic ========= */
function drawCards(playerIndex, count){
  for(let i=0;i<count;i++){
    reshuffleIfNeeded();
    if(deck.length === 0) return;
    const c = deck.pop();
    players[playerIndex].hand.push(c);
    if(playerIndex===0) animateDraw(c);
  }
  sfxDraw();
  renderAll();
}

/* Player clicks Draw button */
drawBtn.addEventListener('click', ()=>{
  if(current !== 0) { setStatus('Not your turn'); return; }
  if(busy) return;
  busy = true;
  reshuffleIfNeeded();
  if(deck.length === 0){ setStatus('No cards to draw'); busy=false; return; }
  const c = deck.pop(); players[0].hand.push(c); sfxDraw(); renderAll();
  log('You drew a card');
  // if playable, let player choose; otherwise end turn after a brief pause
  if(canPlayCard(c,0)){
    setStatus('You drew a playable card — you may play it');
    busy = false;
  } else {
    setTimeout(()=>{ current = getNext(current); updateTurn(); busy=false; }, 700);
  }
});

/* ========= UNO button ========= */
unoBtn.addEventListener('click', ()=>{
  if(players[0].hand.length === 1){
    players[0].unoCalled = true;
    sfxUno();
    log('You called UNO!');
    setStatus('UNO!');
  } else {
    setStatus('You can only call UNO when you have 1 card');
  }
});

/* ========= Wild color picker ========= */
function showColorPicker(){ colorPicker.classList.remove('hidden'); }
function hideColorPicker(){ colorPicker.classList.add('hidden'); }
colorBtns.forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const color = btn.getAttribute('data-color');
    chooseColor(color);
  });
});
function chooseColor(color){
  hideColorPicker();
  if(!waitingColor) return;
  const {playerIndex, played} = waitingColor;
  played.chosenColor = color;
  topColor = color; topValue = played.value;
  waitingColor = null;
  sfxPlay();
  log(`${players[playerIndex].name} chose ${color.toUpperCase()}`);
  // apply special effect for wild4 vs wild
  if(played.value === 'wild'){
    current = getNext(playerIndex);
  } else if(played.value === 'wild4'){
    const nxt = getNext(playerIndex);
    drawCards(nxt,4);
    log(`${players[nxt].name} draws 4`);
    current = getNext(nxt);
  }
  updateTurn();
}

/* ========= AI logic ========= */
async function aiTurn(){
  if(current===0) return;
  if(busy) return;
  busy = true;
  const pid = current;
  const p = players[pid];
  // think delay 1.0 - 1.5s
  const delay = 1000 + Math.random()*500;
  await new Promise(r=>setTimeout(r, delay));
  // find playable indices
  const playable = [];
  for(let i=0;i<p.hand.length;i++) if(canPlayCard(p.hand[i], pid)) playable.push(i);
  if(playable.length === 0){
    // draw one
    reshuffleIfNeeded();
    if(deck.length>0){
      const c = deck.pop(); p.hand.push(c); sfxDraw(); log(`${p.name} drew a card`);
      renderAll();
      // if playable, 70% chance to play immediately
      if(canPlayCard(c,pid) && Math.random()<0.7){
        const idx = p.hand.indexOf(c);
        // play
        await aiPlayIndex(pid, idx);
        busy = false;
        return;
      }
    }
    // else end turn
    current = getNext(current);
    busy = false;
    updateTurn();
    return;
  }
  // choose best card
  let bestIdx = playable[0], bestScore = -999;
  for(const idx of playable){
    const c = p.hand[idx];
    let score = 0;
    if(c.color !== 'wild' && c.color === topColor) score += 5;
    if(c.value === topValue) score += 3;
    if(['skip','reverse','draw2','wild4'].includes(c.value)) score += 2;
    if(c.color === 'wild' && c.value === 'wild') score += 1;
    // if opponents low on cards, prefer action
    const opponent = players.reduce((acc,pl,ix)=> ix !== pid && pl.hand.length < acc.handLength ? {handLength:pl.hand.length, idx:ix} : acc, {handLength:999, idx:-1});
    if(opponent.handLength <= 2 && ['draw2','wild4','skip','reverse'].includes(c.value)) score += 3;
    if(score > bestScore){ bestScore = score; bestIdx = idx; }
  }
  // If best card is wild, pick color strategically
  const chosenCard = p.hand[bestIdx];
  if(chosenCard.color === 'wild'){
    // ensure wild4 legality
    if(chosenCard.value === 'wild4'){
      const hasColorMatch = p.hand.some((h,i) => i!==bestIdx && h.color===topColor && h.color!=='wild');
      if(hasColorMatch){
        // fallback to non-wild if available
        const alt = playable.find(i => p.hand[i].color !== 'wild');
        if(typeof alt !== 'undefined') { bestIdx = alt; }
      }
    }
  }
  // play chosen
  if(p.hand[bestIdx].color === 'wild'){
    // choose color: most frequent color in hand
    const counts = {red:0,yellow:0,green:0,blue:0};
    for(const h of p.hand) if(h.color && h.color!=='wild') counts[h.color]++;
    let pick='red', best=-1;
    for(const k of ['red','yellow','green','blue']) if(counts[k] > best){ best=counts[k]; pick=k; }
    // act like choosing color and playing
    await aiPlayWild(pid, bestIdx, pick);
    busy = false;
    return;
  } else {
    await aiPlayIndex(pid, bestIdx);
    busy = false;
    return;
  }
}

async function aiPlayIndex(pid, idx){
  // remove, push discard
  const [played] = players[pid].hand.splice(idx,1);
  discard.push(played);
  animatePlay(played, pid);
  sfxPlay();
  log(`${players[pid].name} played ${cardText(played)}`);
  // apply effect (slight delay to let animation show)
  await new Promise(r=>setTimeout(r, 420));
  if(played.value === 'skip'){ sfxSkip(); log(`${players[getNext(pid)].name} is skipped`); current = getNext(getNext(pid)); }
  else if(played.value === 'reverse'){ sfxReverse(); direction *= -1; log('Direction reversed'); if(players.length===2) current = getNext(getNext(pid)); else current = getNext(pid); }
  else if(played.value === 'draw2'){ const nxt = getNext(pid); sfxDraw(); drawCards(nxt,2); log(`${players[nxt].name} draws 2`); current = getNext(nxt); }
  else { topColor = played.color; topValue = played.value; current = getNext(pid); }
  // UNO auto-call for AI
  if(players[pid].hand.length === 1){ players[pid].unoCalled = true; sfxUno(); log(`${players[pid].name} called UNO!`); }
  renderAll();
  // if next is AI, continue chain handled by updateTurn()
  updateTurn();
}

async function aiPlayWild(pid, idx, chosenColor){
  const [played] = players[pid].hand.splice(idx,1);
  played.chosenColor = chosenColor;
  discard.push(played);
  animatePlay(played, pid);
  sfxPlay();
  log(`${players[pid].name} played ${played.value} and chose ${chosenColor.toUpperCase()}`);
  await new Promise(r=>setTimeout(r,420));
  if(played.value === 'wild'){ topColor = chosenColor; topValue = 'wild'; current = getNext(pid); }
  else if(played.value === 'wild4'){ topColor = chosenColor; topValue = 'wild4'; const nxt = getNext(pid); sfxDraw(); drawCards(nxt,4); log(`${players[nxt].name} draws 4`); current = getNext(nxt); }
  if(players[pid].hand.length === 1){ players[pid].unoCalled = true; sfxUno(); log(`${players[pid].name} called UNO!`); }
  renderAll(); updateTurn();
}

/* ========= Animations ========= */
function animatePlay(card, playerIndex){
  const el = document.createElement('div');
  el.className = 'playedFloating ' + cardClass(card);
  el.innerHTML = `<div style="padding:8px;font-weight:900;font-size:22px">${cardSymbol(card)}</div>`;
  document.body.appendChild(el);
  // compute start position
  const boardRect = board.getBoundingClientRect();
  let startX = boardRect.left + boardRect.width/2;
  let startY = boardRect.top + boardRect.height/2;
  if(playerIndex === 0){
    const ph = document.getElementById('playerHand').getBoundingClientRect();
    startX = ph.left + ph.width/2;
    startY = ph.top + 20;
  } else {
    const slots = document.querySelectorAll('.aiSlot');
    const slot = slots[playerIndex-1];
    if(slot){ const r=slot.getBoundingClientRect(); startX=r.left + r.width/2; startY=r.top + r.height/2; }
  }
  el.style.left = (startX - 44) + 'px';
  el.style.top = (startY - 62) + 'px';
  el.style.width = '92px'; el.style.height = '128px'; el.style.opacity = '1';
  // destination: discardTop center
  const dest = discardTop.getBoundingClientRect();
  const destX = dest.left + dest.width/2 - 44;
  const destY = dest.top + dest.height/2 - 62;
  requestAnimationFrame(()=>{ el.style.transform = `translate(${destX - (startX - 44)}px, ${destY - (startY - 62)}px) scale(.96)`; el.style.transition='transform .52s cubic-bezier(.17,.67,.32,1), opacity .4s ease'; });
  setTimeout(()=>{ el.remove(); renderPiles(); }, 520);
}
function animateDraw(card){
  const ph = document.getElementById('playerHand').getBoundingClientRect();
  const el = document.createElement('div');
  el.className = 'playedFloating ' + cardClass(card);
  el.innerHTML = `<div style="padding:8px;font-weight:900;font-size:22px">${cardSymbol(card)}</div>`;
  document.body.appendChild(el);
  const boardRect = board.getBoundingClientRect();
  const startX = boardRect.left + boardRect.width/2;
  const startY = boardRect.top + boardRect.height/2;
  el.style.left = (startX - 44) + 'px'; el.style.top = (startY - 62) + 'px'; el.style.width='92px'; el.style.height='128px';
  const destX = ph.left + 40; const destY = ph.top - 20;
  requestAnimationFrame(()=>{ el.style.transform = `translate(${destX - (startX - 44)}px, ${destY - (startY - 62)}px) scale(.8)`; el.style.transition='transform .44s cubic-bezier(.17,.67,.32,1), opacity .4s ease'; });
  setTimeout(()=> el.remove(), 480);
}

/* ========= UNO penalty check ========= */
function checkUnoPenalty(byPlayer){
  for(let i=0;i<players.length;i++){
    if(i===byPlayer) continue;
    if(players[i].hand.length === 1 && !players[i].unoCalled){
      drawCards(i,2);
      log(`${players[i].name} forgot UNO and draws 2`);
      sfxDraw();
      players[i].unoCalled = false;
    }
  }
}

/* ========= Victory overlay ========= */
function showVictory(name){
  victoryOverlay.classList.remove('hidden');
  victoryOverlay.innerHTML = `<div style="font-size:24px;margin-bottom:8px">${name} Wins!</div><div style="margin-top:8px"><button id="restartBtn">Restart</button></div>`;
  document.getElementById('restartBtn').addEventListener('click', ()=>{
    victoryOverlay.classList.add('hidden'); startGame();
  });
  setStatus(`${name} wins!`);
  busy = true;
  sfxWin();
}

/* ========= Helpers ========= */
function cardText(c){ if(!c) return ''; if(c.value==='skip') return `${c.color} SKIP`; if(c.value==='reverse') return `${c.color} REVERSE`; if(c.value==='draw2') return `${c.color} +2`; if(c.value==='wild') return 'WILD'; if(c.value==='wild4') return 'WILD +4'; return `${c.color} ${c.value}`; }

/* ========= Event hooks ========= */
startBtn.addEventListener('click', ()=> startGame());
newBtn.addEventListener('click', ()=> startGame());
board.addEventListener('click', ()=> ensureAudio(), {once:true});
drawBtn.addEventListener('click', ()=> { if(current===0 && !busy){ drawBtn.disabled=true; drawBtnTimeout(); } });
function drawBtnTimeout(){ // wrapper to respect busy flow
  setTimeout(()=> drawBtn.disabled=false, 900);
  // actual draw handled earlier
});
unoBtn.addEventListener('click', ()=> {
  if(players[0].hand.length === 1){ players[0].unoCalled = true; sfxUno(); log('You called UNO!'); setStatus('UNO!'); } else setStatus('You can only call UNO when you have 1 card');
});
colorBtns.forEach(b => b.addEventListener('click', ()=> {
  const c = b.getAttribute('data-color');
  chooseColor(c);
}));

/* ========= Start with hint ========= */
(function init(){
  setStatus('Choose AI count and press Start. Click board to enable audio.');
  document.querySelector('#drawBack').innerText = '0';
  discardTop.innerText = '';
})();

</script>
</body>
</html>
