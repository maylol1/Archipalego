<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>UNO Deluxe — Play vs AI (Single-file)</title>
<style>
  :root{
    --bg:#0b1220; --panel:#071827; --muted:#9fb0c8;
    --red:#ef4444; --yellow:#f59e0b; --green:#10b981; --blue:#3b82f6; --black:#111827;
    --card-w:72px; --card-h:100px;
  }
  *{box-sizing:border-box;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;color:#e6eef8}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#071122,#021826)}
  .wrap{max-width:1200px;margin:18px auto;padding:12px;display:grid;grid-template-columns:1fr 320px;gap:12px}
  .board{background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);padding:14px;border-radius:12px;min-height:78vh;position:relative}
  .panel{background:rgba(2,6,12,0.5);padding:12px;border-radius:10px}
  .controls{display:flex;gap:8px;align-items:center;margin-bottom:8px}
  button{background:#0f1724;border:1px solid rgba(255,255,255,0.04);color:var(--muted);padding:8px 10px;border-radius:8px;cursor:pointer}
  .bright{color:var(--muted)}
  .topArea{display:flex;gap:12px;align-items:center;justify-content:center;margin-bottom:12px}
  #piles{display:flex;gap:18px;align-items:center;justify-content:center;margin-top:18px}
  .pile{width:var(--card-w);height:var(--card-h);border-radius:8px;box-shadow:0 8px 24px rgba(2,6,12,0.6);display:flex;align-items:center;justify-content:center;position:relative;overflow:visible}
  .cardBack{width:100%;height:100%;border-radius:8px;background:linear-gradient(180deg,#072b3c,#041b26);display:flex;align-items:center;justify-content:center;color:#bfe7f8;font-weight:700}
  #discard{display:flex;align-items:center;justify-content:center}
  #discard .cardFace{width:100%;height:100%;border-radius:8px;display:flex;align-items:center;justify-content:center;font-size:20px;font-weight:700;color:#021018;box-shadow:inset 0 -8px 24px rgba(0,0,0,0.08)}
  #playersTop{display:flex;gap:12px;justify-content:center;align-items:end;margin-bottom:12px}
  .aiHand{display:flex;gap:6px;align-items:end}
  .aiCard{width:28px;height:42px;border-radius:6px;background:#041827;border:1px solid rgba(255,255,255,0.03);box-shadow:0 2px 8px rgba(0,0,0,0.6)}
  #log{height:260px;overflow:auto;padding:8px;background:rgba(0,0,0,0.12);border-radius:8px;margin-top:8px}
  #playerHand{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;display:flex;gap:10px;align-items:flex-end;padding:8px;background:transparent}
  .handCard{width:var(--card-w);height:var(--card-h);border-radius:10px;display:flex;flex-direction:column;align-items:center;justify-content:center;font-size:20px;font-weight:800;color:#021018;cursor:pointer;transition:transform .18s ease, box-shadow .18s ease}
  .handCard:hover{transform:translateY(-8px);box-shadow:0 18px 36px rgba(2,6,12,0.6)}
  .small{font-size:13px;color:var(--muted)}
  .big{font-size:18px;font-weight:700}
  .colorLabel{display:inline-block;width:18px;height:18px;border-radius:4px;margin-right:6px;vertical-align:middle}
  #wildColorPicker{display:none;position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(3,6,9,0.94);padding:12px;border-radius:10px;box-shadow:0 12px 40px rgba(0,0,0,0.6)}
  .colorBtn{width:44px;height:44px;border-radius:8px;cursor:pointer;border:2px solid rgba(0,0,0,0.2)}
  .hud{position:absolute;left:16px;top:16px;background:rgba(0,0,0,0.35);padding:8px;border-radius:8px}
  .centerHUD{position:absolute;left:50%;top:14px;transform:translateX(-50%);background:rgba(0,0,0,0.35);padding:8px;border-radius:8px}
  .actionNote{position:absolute;right:16px;top:16px;background:rgba(0,0,0,0.35);padding:8px;border-radius:8px}
  .tiny{font-size:12px;color:var(--muted)}
  @media(max-width:900px){
    .wrap{grid-template-columns:1fr; padding:6px}
    #playerHand{position:fixed;left:8px;transform:none;bottom:8px}
  }
  /* card face styles */
  .face-red{background:linear-gradient(180deg,#ff6b6b,#ef4444);color:white}
  .face-yellow{background:linear-gradient(180deg,#ffd86b,#f59e0b);color:#111}
  .face-green{background:linear-gradient(180deg,#6ee7b7,#10b981);color:#021018}
  .face-blue{background:linear-gradient(180deg,#93c5fd,#3b82f6);color:#021018}
  .face-wild{background:linear-gradient(180deg,#333333,#111827);color:white}
  .cardSym{font-size:22px; font-weight:900}
  .playedAnim{animation: playedIn .28s ease;}
  @keyframes playedIn { from { transform: translateY(20px) scale(0.9); opacity:0 } to { transform:translateY(0) scale(1); opacity:1 } }
  .fadeOut{animation:fadeOut .45s ease forwards}
  @keyframes fadeOut { to { opacity:0; transform: translateY(-10px) } }
</style>
</head>
<body>
<div class="wrap">
  <div class="board panel" id="board">
    <div class="hud small" id="status">Welcome to UNO — choose players and press New Game</div>
    <div class="centerHUD small" id="turnInfo">Turn: -</div>
    <div class="actionNote small" id="actionNote"></div>

    <div id="playersTop" class="small"></div>

    <div id="piles">
      <div class="pile" id="drawPile" title="Draw Pile"><div class="cardBack small">Deck</div></div>
      <div class="pile" id="discard" title="Discard Pile"><div id="topDiscard" class="cardFace"></div></div>
    </div>

    <div id="wildColorPicker">
      <div class="small" style="margin-bottom:8px">Pick a color</div>
      <div style="display:flex;gap:8px">
        <div class="colorBtn" id="pickRed" style="background:var(--red)"></div>
        <div class="colorBtn" id="pickYellow" style="background:var(--yellow)"></div>
        <div class="colorBtn" id="pickGreen" style="background:var(--green)"></div>
        <div class="colorBtn" id="pickBlue" style="background:var(--blue)"></div>
      </div>
    </div>
  </div>

  <div class="panel">
    <div class="controls">
      <label class="small">AI Opponents:</label>
      <select id="aiCount"><option value="2">2 AI (3 players)</option><option value="3">3 AI (4 players)</option></select>
      <button id="newGameBtn">New Game</button>
      <button id="drawBtn">Draw Card</button>
      <button id="unoBtn">Call UNO</button>
    </div>

    <div class="small" style="margin-bottom:6px">Game Messages</div>
    <div id="log" class="small"></div>
    <div style="margin-top:8px" class="small">Controls: Click your card to play (valid ones highlighted). Right now Wild Draw Four is disallowed if you have a matching color card.</div>
    <div style="margin-top:12px" class="small">Sounds: enabled via Web Audio (no external files)</div>
  </div>
</div>

<!-- Player hand container (fixed at bottom) -->
<div id="playerHand"></div>

<script>
/* UNO Deluxe — Single-file
   Features:
   - Full UNO deck (108 cards)
   - 2 or 3 AI opponents selectable
   - Classic colors (red, yellow, green, blue, wild)
   - Animations & WebAudio-based sound effects
   - Wild color chooser popup
   - UNO button & penalty
   - Prevent Wild Draw 4 illegal plays
*/

/* -------------------------
   Utilities & Sound (Web Audio)
   ------------------------- */
const logEl = document.getElementById('log');
function log(msg){ const t = document.createElement('div'); t.innerText = msg; logEl.prepend(t); }

// WebAudio context & helper functions to produce nicer sounds
const AudioCtx = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioCtx();
function playToneSequence(params){
  // params: array of {freq, dur, type, volume}
  const now = audioCtx.currentTime;
  let time = now;
  for(const p of params){
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = p.type || 'sine';
    osc.frequency.setValueAtTime(p.freq, time);
    gain.gain.setValueAtTime(0.0001, time);
    gain.gain.exponentialRampToValueAtTime((p.volume||0.08), time + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.0001, time + p.dur - 0.02);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(time); osc.stop(time + p.dur);
    time += p.dur;
  }
}

// richer effects
function playShuffle(){
  // multiple descending noise-like blips
  const seq = [
    {freq:1200, dur:0.06, type:'sawtooth', volume:0.06},
    {freq:900, dur:0.08, type:'sawtooth', volume:0.06},
    {freq:700, dur:0.09, type:'sine', volume:0.05},
    {freq:500, dur:0.12, type:'sine', volume:0.05}
  ];
  playToneSequence(seq);
}
function playCardPlay(){
  playToneSequence([{freq:880,dur:0.09,type:'triangle',volume:0.06},{freq:1320,dur:0.06,type:'sine',volume:0.04}]);
}
function playDraw(){
  playToneSequence([{freq:520,dur:0.07,type:'sine',volume:0.06},{freq:680,dur:0.06,type:'sine',volume:0.04}]);
}
function playSkip(){
  playToneSequence([{freq:420,dur:0.08,type:'square',volume:0.06},{freq:320,dur:0.05,type:'square',volume:0.05}]);
}
function playReverse(){
  playToneSequence([{freq:720,dur:0.09,type:'triangle',volume:0.06},{freq:880,dur:0.08,type:'triangle',volume:0.05}]);
}
function playUnoCall(){
  playToneSequence([{freq:1000,dur:0.18,type:'sine',volume:0.09},{freq:1200,dur:0.12,type:'sine',volume:0.07}]);
}
function playVictory(){
  playToneSequence([{freq:880,dur:0.12,type:'triangle',volume:0.09},{freq:1100,dur:0.10,type:'triangle',volume:0.08},{freq:1320,dur:0.14,type:'sawtooth',volume:0.1}]);
}

/* -------------------------
   Representing cards & deck
   ------------------------- */
/*
 Card object: {color: 'red'|'yellow'|'green'|'blue'|'wild', value: '0'..'9' | 'skip' | 'reverse' | 'draw2' | 'wild' | 'wild4'}
*/
function createFullDeck(){
  const colors = ['red','yellow','green','blue'];
  const deck = [];
  // Number cards: one 0 per color, two of 1-9 per color
  for(const c of colors){
    deck.push({color:c, value:'0'});
    for(let n=1;n<=9;n++){
      deck.push({color:c, value: String(n)});
      deck.push({color:c, value: String(n)});
    }
    // Action cards: two of each per color
    for(let i=0;i<2;i++){
      deck.push({color:c, value:'skip'});
      deck.push({color:c, value:'reverse'});
      deck.push({color:c, value:'draw2'});
    }
  }
  // Wild cards: 4 wild, 4 wild draw four
  for(let i=0;i<4;i++) deck.push({color:'wild', value:'wild'});
  for(let i=0;i<4;i++) deck.push({color:'wild', value:'wild4'});
  // total should be 108
  return deck;
}
function shuffleDeck(deck){
  // Fisher-Yates
  for(let i=deck.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [deck[i],deck[j]] = [deck[j],deck[i]];
  }
  playShuffle();
  return deck;
}

/* -------------------------
   Game state
   ------------------------- */
let deck = []; // draw pile
let discard = []; // discard pile (top is last)
let players = []; // array of {name, hand:[], isAI:true/false, unoCalled:false}
let currentPlayer = 0;
let playDirection = 1; // 1 for clockwise, -1 for counterclockwise
let topColor = null; // effective color for matching (when wild chosen)
let topValue = null;
let skipNext = false;
let drawStack = 0; // stacking draw2/draw4? We'll implement standard: draw effects applied, not stacking
let waitingColorPick = null; // when someone played wild/wild4 and needs to pick color
let aiCountSelect = document.getElementById('aiCount');

/* -------------------------
   UI references
   ------------------------- */
const drawBtn = document.getElementById('drawBtn');
const unoBtn = document.getElementById('unoBtn');
const newGameBtn = document.getElementById('newGameBtn');
const playerHandEl = document.getElementById('playerHand');
const drawPileEl = document.getElementById('drawPile');
const discardEl = document.getElementById('topDiscard');
const playersTopEl = document.getElementById('playersTop');
const statusEl = document.getElementById('status');
const turnInfoEl = document.getElementById('turnInfo');
const actionNoteEl = document.getElementById('actionNote');
const wildPicker = document.getElementById('wildColorPicker');
const pickRed = document.getElementById('pickRed');
const pickYellow = document.getElementById('pickYellow');
const pickGreen = document.getElementById('pickGreen');
const pickBlue = document.getElementById('pickBlue');

/* -------------------------
   Helper functions
   ------------------------- */
function cardHTML(card){
  if(!card) return '';
  const cls = card.color==='wild' ? 'face-wild' : (card.color==='red'?'face-red':(card.color==='yellow'?'face-yellow':(card.color==='green'?'face-green':'face-blue')));
  const display = (card.value==='skip' ? '⏭' : (card.value==='reverse'?'⤾':(card.value==='draw2'?'+2':(card.value==='wild'?'★':(card.value==='wild4'?'+4':card.value)))));
  return `<div class="cardFace ${cls}"><div class="cardSym">${display}</div></div>`;
}
function updateTopDiscard(){
  const top = discard[discard.length-1];
  discardEl.innerHTML = cardHTML(top);
  // update turn text color possibly
  if(top){
    topColor = (top.color==='wild' && top.chosenColor) ? top.chosenColor : top.color;
    topValue = top.value;
  } else { topColor = null; topValue = null; }
}

/* -------------------------
   Start New Game
   ------------------------- */
function newGame(){
  // init
  deck = shuffleDeck(createFullDeck());
  discard = [];
  players = [];
  const aiCount = parseInt(aiCountSelect.value,10);
  // human player at index 0
  players.push({name:'You', hand:[], isAI:false, unoCalled:false});
  for(let i=1;i<=aiCount;i++) players.push({name: 'AI ' + i, hand:[], isAI:true, unoCalled:false});
  currentPlayer = 0; playDirection = 1; drawStack = 0; waitingColorPick = null;
  // deal 7 each
  for(let r=0;r<7;r++){
    for(let p=0;p<players.length;p++){
      players[p].hand.push(deck.pop());
    }
  }
  // flip first non-wild card to start
  let first = deck.pop();
  while(first.value==='wild' || first.value==='wild4'){
    deck.unshift(first); // put back deeper
    shuffleDeck(deck); // shuffle again
    first = deck.pop();
  }
  discard.push(first);
  updateTopDiscard();
  // reset UNO call flags
  players.forEach(p=>p.unoCalled=false);
  // render UI
  renderPlayersTop();
  renderPlayerHand();
  updateStatus('New game started');
  log('Game started. Top card: ' + cardText(first));
  // apply initial action if first card is action (skip/draw2/reverse)
  if(first.value === 'skip'){
    advanceTurn();
    updateStatus('First card was Skip — first player skipped');
  } else if(first.value === 'reverse'){
    playDirection *= -1;
    updateStatus('Play direction reversed by initial card');
  } else if(first.value === 'draw2'){
    // next player draws two and misses turn
    const next = getNextIndex(currentPlayer);
    drawCardsForPlayer(next, 2);
    advanceTurn();
    updateStatus('First card was Draw Two — next player drew 2 and skipped');
  }
  updateTopDiscard();
  renderPlayersTop();
  renderPlayerHand();
  renderPiles();
  updateTurnInfo();
}

/* -------------------------
   Utilities - indexing & rotation
   ------------------------- */
function getNextIndex(idx){
  return (idx + playDirection + players.length) % players.length;
}
function advanceTurn(){
  currentPlayer = getNextIndex(currentPlayer);
  // reset UNO flags if needed
  players.forEach(p=>{ if(p.hand.length !== 1) p.unoCalled = false; });
}

/* -------------------------
   Actions: draw, play, apply effects
   ------------------------- */
function drawCardsForPlayer(pid, count){
  for(let i=0;i<count;i++){
    if(deck.length === 0) reshuffleDiscardIntoDeck();
    if(deck.length === 0) { log('No cards left to draw'); break; }
    const c = deck.pop();
    players[pid].hand.push(c);
    if(pid === 0){
      animateDrawCardToHand(c);
    }
  }
  playDraw();
  renderPlayerHand();
  renderPlayersTop();
  renderPiles();
}

function reshuffleDiscardIntoDeck(){
  if(discard.length <= 1) return;
  const top = discard.pop();
  deck = shuffleDeck(discard.splice(0, discard.length));
  discard = [top];
  updateTopDiscard();
  log('Reshuffled discard into deck');
}

function canPlayCard(card){
  if(!card) return false;
  // wild/wild4 always playable by color matching rules? Wild is always playable; wild4 only if no card in hand matches topColor
  if(card.color === 'wild'){
    if(card.value === 'wild4'){
      // check for illegal play: if player does have a card that matches current color, disallow wild4
      const hand = players[0].hand;
      const hasColorMatch = hand.some(h => h.color === topColor && h.color !== 'wild');
      if(hasColorMatch) return false;
      return true;
    }
    return true;
  }
  // color match OR value match OR number/symbol match
  if(topColor === card.color) return true;
  if(topValue === card.value) return true;
  return false;
}

function aiCanPlayAny(pid){
  const hand = players[pid].hand;
  for(const c of hand){
    if(aiCanPlayCard(pid, c)) return true;
  }
  return false;
}
function aiCanPlayCard(pid, card){
  // for AI, allow wild4 only if no color-match in hand
  if(card.color === 'wild' && card.value === 'wild4'){
    const hand = players[pid].hand;
    const hasColorMatch = hand.some(h => h.color === topColor && h.color !== 'wild');
    if(hasColorMatch) return false;
    return true;
  }
  if(card.color === 'wild') return true;
  if(topColor === card.color) return true;
  if(topValue === card.value) return true;
  return false;
}

function cardText(card){
  if(!card) return '';
  if(card.value === 'skip') return `${card.color.toUpperCase()} Skip`;
  if(card.value === 'reverse') return `${card.color.toUpperCase()} Reverse`;
  if(card.value === 'draw2') return `${card.color.toUpperCase()} +2`;
  if(card.value === 'wild') return `Wild`;
  if(card.value === 'wild4') return `Wild +4`;
  return `${card.color.toUpperCase()} ${card.value}`;
}

function playCard(pid, cardIndex){
  const hand = players[pid].hand;
  if(cardIndex < 0 || cardIndex >= hand.length) return false;
  const card = hand[cardIndex];
  // validation: player's turn?
  if(pid !== currentPlayer) return false;
  // if needs color pick (wild) show picker
  if(card.color === 'wild'){
    // for wild4 also check illegal play rule for human
    if(card.value === 'wild4'){
      // check if human/AI has matching color card in hand
      const hasColorMatch = hand.some((h,idx) => h.color === topColor && h.color !== 'wild' && idx !== cardIndex);
      if(hasColorMatch && pid === 0){
        updateStatus('Illegal Wild Draw Four play — you have a matching color card.');
        log('Illegal attempt: Wild Draw 4 when a color match exists.');
        return false;
      } else if(hasColorMatch && pid !== 0){
        // AI shouldn't play it - disallow
        return false;
      }
    }
    // wait for color pick
    waitingColorPick = {pid, cardIndex};
    showColorPicker();
    return true;
  } else {
    // regular colored card
    if(pid === 0 && !canPlayCard(card)){ updateStatus('Cannot play that card now'); return false; }
    if(pid !== 0 && !aiCanPlayCard(pid, card)) return false;
    // move to discard
    const played = hand.splice(cardIndex,1)[0];
    discard.push(played);
    updateTopDiscard();
    playCardPlay();
    log(`${players[pid].name} played ${cardText(played)}`);
    // handle actions: skip, reverse, draw2
    applyCardEffect(pid, played);
    // UNO logic: if the player now has 1 card, require UNO call
    if(players[pid].hand.length === 1 && !players[pid].unoCalled){
      // for human, show reminder; for AI pick random chance to 'forget' (we'll let AI call UNO automatically most of time)
      if(pid !== 0){ // AI auto-call
        players[pid].unoCalled = true;
        log(`${players[pid].name} called UNO!`);
      } else {
        updateActionNote('You have 1 card — press UNO button!', 3000);
      }
    }
    // victory check
    if(players[pid].hand.length === 0){
      playVictory();
      updateStatus(`${players[pid].name} wins the round!`);
      log(`${players[pid].name} wins!`);
      // highlight and disable draw/play
      disableInteraction();
      return true;
    }
    // advance turn logic depends on effect (some actions already advanced)
    if(!['skip','draw2','wild4'].includes(played.value)){
      // normal flow: go to next player
      advanceTurn();
    }
    updateTurnInfo();
    renderPlayerHand();
    renderPlayersTop();
    renderPiles();
    return true;
  }
}

function applyCardEffect(pid, card){
  // card already placed on discard
  if(card.value === 'skip'){
    // skip next player
    playSkip();
    const skipped = getNextIndex(pid);
    log(`${players[skipped].name} was skipped`);
    // advance extra
    advanceTurn(); // move to next player
    advanceTurn(); // skip them
  } else if(card.value === 'reverse'){
    playReverse();
    playDirection *= -1;
    // If only two players, reverse acts as skip of opponent (UNO rule)
    if(players.length === 2){
      // reverse acts like skip
      advanceTurn();
    } else {
      // simply change direction and advance once
      advanceTurn();
    }
  } else if(card.value === 'draw2'){
    // next player draws two and loses turn
    const next = getNextIndex(pid);
    drawCardsForPlayer(next, 2);
    advanceTurn(); // skip next
    advanceTurn();
  } else if(card.value === 'wild4'){
    // next player draws 4 and loses turn — chosen color is in card.chosenColor (set after color picker)
    const next = getNextIndex(pid);
    drawCardsForPlayer(next, 4);
    advanceTurn();
    advanceTurn();
  } else {
    // normal number card -> just play
  }
}

/* -------------------------
   Color picker & wild handling
   ------------------------- */
function showColorPicker(){
  wildPicker.style.display = 'block';
}
function hideColorPicker(){
  wildPicker.style.display = 'none';
}
function chooseColor(color){
  if(!waitingColorPick) return;
  const {pid, cardIndex} = waitingColorPick;
  const hand = players[pid].hand;
  const card = hand.splice(cardIndex,1)[0];
  // set chosen color on card so discard shows it
  card.chosenColor = color;
  discard.push(card);
  updateTopDiscard();
  hideColorPicker();
  waitingColorPick = null;
  playCardPlay();
  log(`${players[pid].name} played ${card.value === 'wild' ? 'Wild' : 'Wild Draw 4'} and chose ${color.toUpperCase()}`);
  // apply effect
  if(card.value === 'wild'){
    // no further immediate effect, advance turn
    topColor = color;
    advanceTurn();
  } else if(card.value === 'wild4'){
    // wild4: draw 4 to next and skip
    topColor = color;
    const next = getNextIndex(pid);
    drawCardsForPlayer(next, 4);
    advanceTurn(); // skip
    advanceTurn();
  }
  // UNO: if player ended with one card, prompt/auto-call
  if(players[pid].hand.length === 1 && pid !== 0){ players[pid].unoCalled = true; }
  updateTurnInfo(); renderPlayerHand(); renderPlayersTop(); renderPiles();
}

/* -------------------------
   Player Draw action (button)
   ------------------------- */
drawBtn.addEventListener('click', ()=>{
  if(currentPlayer !== 0) { updateStatus('Not your turn'); return; }
  if(deck.length === 0) reshuffleDiscardIntoDeck();
  if(deck.length === 0){ updateStatus('No cards left to draw'); return; }
  const c = deck.pop();
  players[0].hand.push(c);
  animateDrawCardToHand(c);
  playDraw();
  renderPiles();
  renderPlayerHand();
  // If new card is playable, player may play it, else turn ends
  const playable = canPlayCard(c);
  if(!playable){
    updateStatus('You drew a card and have no valid play — turn ends');
    // advance turn
    advanceTurn();
    updateTurnInfo();
    setTimeout(() => { aiTurnIfNeeded(); }, 800);
  } else {
    updateStatus('You drew a playable card — you may play it');
  }
});

/* -------------------------
   UNO button
   ------------------------- */
unoBtn.addEventListener('click', ()=>{
  if(players[0].hand.length === 1){
    players[0].unoCalled = true;
    playUnoCall();
    updateStatus('You called UNO!');
    log('You called UNO!');
  } else {
    // pressing UNO when not 1 card -> penalty?
    updateStatus('You can only call UNO when you have 1 card');
  }
});

/* -------------------------
   AI logic
   ------------------------- */
function aiTurnIfNeeded(){
  if(stateEnded()) return;
  if(currentPlayer === 0) return;
  const pid = currentPlayer;
  const p = players[pid];
  // small delay for AI to "think"
  setTimeout(() => {
    // find playable cards
    const playable = [];
    for(let i=0;i<p.hand.length;i++){
      if(aiCanPlayCard(pid, p.hand[i])) playable.push({idx:i, card:p.hand[i]});
    }
    if(playable.length === 0){
      // draw one card
      if(deck.length === 0) reshuffleDiscardIntoDeck();
      if(deck.length > 0){
        const c = deck.pop();
        p.hand.push(c);
        playDraw();
        log(`${p.name} drew a card`);
        // if playable, 50% chance to play immediately
        const justPlayable = aiCanPlayCard(pid, c);
        if(justPlayable && Math.random() < 0.9){
          // play it
          const idx = p.hand.length -1;
          aiPlayCard(pid, idx);
          return;
        }
      }
      // end turn
      advanceTurn();
      updateTurnInfo();
      renderPlayersTop();
      renderPiles();
      // next AI or player
      setTimeout(() => { aiTurnIfNeeded(); }, 600);
    } else {
      // choose card with preference: color match -> value match -> wild -> wild4 (only if legal)
      // score them
      playable.sort((a,b)=>{
        const as = scoreCardForAI(a.card), bs = scoreCardForAI(b.card);
        return bs - as;
      });
      const choice = playable[0];
      aiPlayCard(pid, choice.idx);
    }
  }, 700 + Math.random()*700);
}

function scoreCardForAI(card){
  // prefer color match first (value 5), then number/symbol match (3), then wild(2), wild4(1)
  let score = 0;
  if(card.color !== 'wild' && card.color === topColor) score += 5;
  if(card.value === topValue) score += 3;
  if(card.color === 'wild' && card.value === 'wild') score += 2;
  if(card.color === 'wild' && card.value === 'wild4') score += 1;
  // prefer action cards if opponent has few cards
  const opponents = players.filter((_,i)=>i!==currentPlayer);
  const nearestOpp = opponents.reduce((a,b)=> (a.hand.length < b.hand.length ? a : b));
  if(nearestOpp.hand.length <= 2 && ['skip','reverse','draw2','wild4'].includes(card.value)) score += 3;
  return score;
}

function aiPlayCard(pid, cardIndex){
  const p = players[pid];
  const card = p.hand[cardIndex];
  // for wilds, pick random color
  if(card.color === 'wild'){
    // check legality for wild4
    if(card.value === 'wild4'){
      const hasColorMatch = p.hand.some((h,idx) => h.color === topColor && h.color !== 'wild' && idx !== cardIndex);
      if(hasColorMatch){ 
        // can't play it; fallback: play other wild or other card; if impossible, draw
        // try to find another playable
        for(let i=0;i<p.hand.length;i++){
          if(i===cardIndex) continue;
          if(aiCanPlayCard(pid, p.hand[i])) { aiPlayCard(pid,i); return; }
        }
        // else draw
        if(deck.length>0){ const c = deck.pop(); p.hand.push(c); log(`${p.name} drew a card`); }
        advanceTurn(); updateTurnInfo(); renderPlayersTop(); renderPiles(); return;
      }
    }
    // choose random color weighted by what's in AI's hand
    const counts = {red:0,yellow:0,green:0,blue:0};
    for(const h of p.hand) if(h.color && h.color!=='wild') counts[h.color]++;
    let chosen = 'red';
    let best = -1;
    for(const k of ['red','yellow','green','blue']) if(counts[k] > best){ best = counts[k]; chosen = k; }
    // if tied, random
    if(best === 0) chosen = ['red','yellow','green','blue'][Math.floor(Math.random()*4)];
    // set chosen color on card and play
    const played = p.hand.splice(cardIndex,1)[0];
    played.chosenColor = chosen;
    discard.push(played);
    updateTopDiscard();
    playCardPlay();
    log(`${p.name} played ${played.value.toUpperCase()} and chose ${chosen.toUpperCase()}`);
    if(played.value === 'wild') {
      topColor = chosen;
      advanceTurn();
    } else if(played.value === 'wild4'){
      topColor = chosen;
      const next = getNextIndex(pid);
      drawCardsForPlayer(next,4);
      advanceTurn(); advanceTurn();
    }
    // UNO logic
    if(p.hand.length === 1){ p.unoCalled = true; log(`${p.name} called UNO!`); }
    // victory check
    if(p.hand.length === 0){
      playVictory();
      updateStatus(`${p.name} wins!`);
      disableInteraction();
      return;
    }
    renderPlayersTop(); renderPiles(); updateTurnInfo();
  } else {
    // normal colored card: validate (should be valid)
    if(!aiCanPlayCard(pid, card)){ /* fallback */ }
    const played = p.hand.splice(cardIndex,1)[0];
    discard.push(played);
    updateTopDiscard();
    playCardPlay();
    log(`${p.name} played ${cardText(played)}`);
    applyCardEffect(pid, played);
    // UNO
    if(p.hand.length === 1){ p.unoCalled = true; log(`${p.name} called UNO!`); }
    if(p.hand.length === 0){
      playVictory();
      updateStatus(`${p.name} wins!`);
      disableInteraction();
      return;
    }
    renderPlayersTop(); renderPiles(); renderPlayerHand();
    updateTurnInfo();
  }
}

/* -------------------------
   Rendering helpers
   ------------------------- */
function renderPiles(){
  // draw count on deck
  const back = document.querySelector('#drawPile .cardBack');
  back.textContent = deck.length;
  updateTopDiscard();
}
function renderPlayerHand(){
  // clear and render bottom player hand
  playerHandEl.innerHTML = '';
  const hand = players[0].hand;
  // highlight playable card(s)
  for(let i=0;i<hand.length;i++){
    const c = hand[i];
    const el = document.createElement('div');
    el.className = 'handCard ' + (c.color==='wild' ? 'face-wild' : (c.color==='red'?'face-red':(c.color==='yellow'?'face-yellow':(c.color==='green'?'face-green':'face-blue'))));
    el.innerHTML = `<div style="font-size:18px">${c.value==='skip'?'⏭':(c.value==='reverse'?'⤾':(c.value==='draw2'?'+2':(c.value==='wild'?'★':(c.value==='wild4'?'+4':c.value))))}</div>`;
    // highlight if playable
    if(canPlayCard(c)) { el.style.boxShadow = '0 18px 36px rgba(0,0,0,0.6), 0 0 0 4px rgba(125,211,252,0.06)'; el.style.transform='translateY(-6px)'; }
    el.addEventListener('click', ()=>{ 
      // play attempt
      if(canPlayCard(c)){
        // locate exact index again - in case changed
        const idx = players[0].hand.indexOf(c);
        playCard(0, idx);
        // if not waiting for color, and turn moved to AI, trigger AI
        renderPlayerHand();
        renderPlayersTop();
        renderPiles();
        updateTurnInfo();
        if(currentPlayer !== 0) setTimeout(()=>aiTurnIfNeeded(), 600);
      } else {
        updateStatus('Cannot play that card');
      }
    });
    playerHandEl.appendChild(el);
  }
}

function renderPlayersTop(){
  playersTopEl.innerHTML = '';
  for(let i=1;i<players.length;i++){
    const p = players[i];
    const cont = document.createElement('div');
    cont.className = 'aiHand';
    cont.style.flexDirection = 'column';
    const label = document.createElement('div');
    label.className = 'small'; label.textContent = `${p.name} (${p.hand.length})`;
    const row = document.createElement('div'); row.style.display='flex'; row.style.gap='6px';
    // show face-down cards as small
    for(let j=0;j<Math.min(p.hand.length,10);j++){
      const card = document.createElement('div'); card.className='aiCard';
      row.appendChild(card);
    }
    cont.appendChild(row); cont.appendChild(label);
    playersTopEl.appendChild(cont);
  }
}

/* -------------------------
   Animations
   ------------------------- */
function animateDrawCardToHand(card){
  // simple brief flash to indicate draw (no DOM card fly for brevity)
  playDraw();
}

/* -------------------------
   Turn & status updates
   ------------------------- */
function updateTurnInfo(){
  turnInfoEl.textContent = `Turn: ${players[currentPlayer].name}`;
  statusEl.textContent = `Top: ${topColor ? topColor.toUpperCase() : ''} ${topValue ? topValue : ''}`;
  // If it is AI's turn, trigger AI
  if(currentPlayer !== 0){
    setTimeout(()=>{ aiTurnIfNeeded(); }, 600);
  }
}

function updateStatus(msg){
  actionNoteEl.innerText = msg;
  setTimeout(()=>{ if(actionNoteEl.innerText === msg) actionNoteEl.innerText = ''; }, 3000);
  log(msg);
}

function disableInteraction(){
  // disable draw/drawBtn/unobutton (simple: hide)
  drawBtn.disabled = true; unoBtn.disabled = true; newGameBtn.disabled = false;
}

/* -------------------------
   UNO penalty enforcement
   ------------------------- */
// When someone has 1 card but didn't call UNO (players[].unoCalled false) and another player plays before they call, they should be penalized (+2)
function checkUnoPenaltyOnAction(byPlayerIndex){
  // any other player with 1 card and unoCalled=false gets penalty
  for(let i=0;i<players.length;i++){
    if(i === byPlayerIndex) continue;
    if(players[i].hand.length === 1 && !players[i].unoCalled){
      // penalty
      drawCardsForPlayer(i,2);
      updateStatus(`${players[i].name} forgot UNO and draws 2!`);
      log(`${players[i].name} forgot UNO and was penalized`);
      // mark they still have 1+ cards (or more)
      players[i].unoCalled = false;
    }
  }
}

/* -------------------------
   Event Listeners for wild color pick
   ------------------------- */
pickRed.addEventListener('click', ()=>{ chooseColor('red'); });
pickYellow.addEventListener('click', ()=>{ chooseColor('yellow'); });
pickGreen.addEventListener('click', ()=>{ chooseColor('green'); });
pickBlue.addEventListener('click', ()=>{ chooseColor('blue'); });

/* -------------------------
   Helpers: disable card play UI if not player's turn
   ------------------------- */
function stateEnded(){
  // check if any player has 0 cards and game ended
  return players.some(p=>p.hand && p.hand.length === 0);
}

/* -------------------------
   Button wired new game
   ------------------------- */
newGameBtn.addEventListener('click', ()=>{
  newGame();
  renderPlayerHand();
  renderPlayersTop();
  renderPiles();
  updateTurnInfo();
});

/* -------------------------
   Initial state
   ------------------------- */
(function init(){
  // set up initial rending and disable draw/uno until start
  drawBtn.disabled = false; unoBtn.disabled = false;
  // initial empty piles
  deck = []; discard = [];
  updateTopDiscard();
  renderPiles();
  updateStatus('Ready. Choose AI count and press New Game.');
})();

</script>
</body>
</html>
